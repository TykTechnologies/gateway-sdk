/*
Tyk Gateway API

The Tyk Gateway API is the primary means for integrating your application with the Tyk API Gateway system. This API is very small, and has no granular permissions system. It is intended to be used purely for internal automation and integration.  **Warning: Under no circumstances should outside parties be granted access to this API.**  The Tyk Gateway API is capable of:  * Managing session objects (key generation). * Managing and listing policies. * Managing and listing API Definitions (only when not using the Tyk Dashboard). * Hot reloads / reloading a cluster configuration. * OAuth client creation (only when not using the Tyk Dashboard).  In order to use the Gateway API, you'll need to set the **secret** parameter in your tyk.conf file.  The shared secret you set should then be sent along as a header with each Gateway API Request in order for it to be successful:  **x-tyk-authorization: <your-secret>*** <br/>  <b>The Tyk Gateway API is subsumed by the Tyk Dashboard API in Pro installations.</b>

API version: 5.7.1
Contact: support@tyk.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package apim

import (
	"encoding/json"
	"fmt"
	"gopkg.in/validator.v2"
)

// GetOAuthClientTokens200Response - struct for GetOAuthClientTokens200Response
type GetOAuthClientTokens200Response struct {
	PaginatedOAuthClientTokens *PaginatedOAuthClientTokens
	ArrayOfOAuthClientToken    *[]OAuthClientToken
}

// PaginatedOAuthClientTokensAsGetOAuthClientTokens200Response is a convenience function that returns PaginatedOAuthClientTokens wrapped in GetOAuthClientTokens200Response
func PaginatedOAuthClientTokensAsGetOAuthClientTokens200Response(v *PaginatedOAuthClientTokens) GetOAuthClientTokens200Response {
	return GetOAuthClientTokens200Response{
		PaginatedOAuthClientTokens: v,
	}
}

// []OAuthClientTokenAsGetOAuthClientTokens200Response is a convenience function that returns []OAuthClientToken wrapped in GetOAuthClientTokens200Response
func ArrayOfOAuthClientTokenAsGetOAuthClientTokens200Response(v *[]OAuthClientToken) GetOAuthClientTokens200Response {
	return GetOAuthClientTokens200Response{
		ArrayOfOAuthClientToken: v,
	}
}

// Unmarshal JSON data into one of the pointers in the struct
func (dst *GetOAuthClientTokens200Response) UnmarshalJSON(data []byte) error {
	var err error
	match := 0
	// try to unmarshal data into PaginatedOAuthClientTokens
	err = newStrictDecoder(data).Decode(&dst.PaginatedOAuthClientTokens)
	if err == nil {
		jsonPaginatedOAuthClientTokens, _ := json.Marshal(dst.PaginatedOAuthClientTokens)
		if string(jsonPaginatedOAuthClientTokens) == "{}" { // empty struct
			dst.PaginatedOAuthClientTokens = nil
		} else {
			if err = validator.Validate(dst.PaginatedOAuthClientTokens); err != nil {
				dst.PaginatedOAuthClientTokens = nil
			} else {
				match++
			}
		}
	} else {
		dst.PaginatedOAuthClientTokens = nil
	}

	// try to unmarshal data into ArrayOfOAuthClientToken
	err = newStrictDecoder(data).Decode(&dst.ArrayOfOAuthClientToken)
	if err == nil {
		jsonArrayOfOAuthClientToken, _ := json.Marshal(dst.ArrayOfOAuthClientToken)
		if string(jsonArrayOfOAuthClientToken) == "{}" { // empty struct
			dst.ArrayOfOAuthClientToken = nil
		} else {
			if err = validator.Validate(dst.ArrayOfOAuthClientToken); err != nil {
				dst.ArrayOfOAuthClientToken = nil
			} else {
				match++
			}
		}
	} else {
		dst.ArrayOfOAuthClientToken = nil
	}

	if match > 1 { // more than 1 match
		// reset to nil
		dst.PaginatedOAuthClientTokens = nil
		dst.ArrayOfOAuthClientToken = nil

		return fmt.Errorf("data matches more than one schema in oneOf(GetOAuthClientTokens200Response)")
	} else if match == 1 {
		return nil // exactly one match
	} else { // no match
		return fmt.Errorf("data failed to match schemas in oneOf(GetOAuthClientTokens200Response)")
	}
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src GetOAuthClientTokens200Response) MarshalJSON() ([]byte, error) {
	if src.PaginatedOAuthClientTokens != nil {
		return json.Marshal(&src.PaginatedOAuthClientTokens)
	}

	if src.ArrayOfOAuthClientToken != nil {
		return json.Marshal(&src.ArrayOfOAuthClientToken)
	}

	return nil, nil // no data in oneOf schemas
}

// Get the actual instance
func (obj *GetOAuthClientTokens200Response) GetActualInstance() interface{} {
	if obj == nil {
		return nil
	}
	if obj.PaginatedOAuthClientTokens != nil {
		return obj.PaginatedOAuthClientTokens
	}

	if obj.ArrayOfOAuthClientToken != nil {
		return obj.ArrayOfOAuthClientToken
	}

	// all schemas are nil
	return nil
}

type NullableGetOAuthClientTokens200Response struct {
	value *GetOAuthClientTokens200Response
	isSet bool
}

func (v NullableGetOAuthClientTokens200Response) Get() *GetOAuthClientTokens200Response {
	return v.value
}

func (v *NullableGetOAuthClientTokens200Response) Set(val *GetOAuthClientTokens200Response) {
	v.value = val
	v.isSet = true
}

func (v NullableGetOAuthClientTokens200Response) IsSet() bool {
	return v.isSet
}

func (v *NullableGetOAuthClientTokens200Response) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableGetOAuthClientTokens200Response(val *GetOAuthClientTokens200Response) *NullableGetOAuthClientTokens200Response {
	return &NullableGetOAuthClientTokens200Response{value: val, isSet: true}
}

func (v NullableGetOAuthClientTokens200Response) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableGetOAuthClientTokens200Response) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
