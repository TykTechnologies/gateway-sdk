/*
Tyk Gateway API

The Tyk Gateway API is the primary means for integrating your application with the Tyk API Gateway system. This API is very small, and has no granular permissions system. It is intended to be used purely for internal automation and integration.  **Warning: Under no circumstances should outside parties be granted access to this API.**  The Tyk Gateway API is capable of:  * Managing session objects (key generation) * Managing and listing policies * Managing and listing API Definitions (only when not using the Dashboard) * Hot reloads / reloading a cluster configuration * OAuth client creation (only when not using the Dashboard)   In order to use the Gateway API, you'll need to set the `secret` parameter in your tyk.conf file.  The shared secret you set should then be sent along as a header with each Gateway API Request in order for it to be successful:  ``` x-tyk-authorization: <your-secret> ``` <br/> <b>The Tyk Gateway API is subsumed by the Tyk Dashboard API in Pro installations.</b>

API version: 4.3.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package apim

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type OASAPIsAPI interface {

	/*
	CreateApiOAS Method for CreateApiOAS

	Create API with OAS format
 A single Tyk node can have its API Definitions queried, deleted and updated remotely. This functionality enables you to remotely update your Tyk definitions without having to manage the files manually.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateApiOASRequest
	*/
	CreateApiOAS(ctx context.Context) ApiCreateApiOASRequest

	// CreateApiOASExecute executes the request
	//  @return ApiModifyKeySuccess
	CreateApiOASExecute(r ApiCreateApiOASRequest) (*ApiModifyKeySuccess, *http.Response, error)

	/*
	DeleteOASApi Method for DeleteOASApi

	Deleting an API definition will remove the file from the file store, the API definition will NOT be unloaded, a separate reload request will need to be made to disable the API endpoint.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param apiID The API ID
	@return ApiDeleteOASApiRequest
	*/
	DeleteOASApi(ctx context.Context, apiID string) ApiDeleteOASApiRequest

	// DeleteOASApiExecute executes the request
	//  @return ApiStatusMessage
	DeleteOASApiExecute(r ApiDeleteOASApiRequest) (*ApiStatusMessage, *http.Response, error)

	/*
	DownloadApiOASPublic Method for DownloadApiOASPublic

	Download all OAS format APIs, when used without the Tyk Dashboard.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param apiID The API ID
	@return ApiDownloadApiOASPublicRequest
	*/
	DownloadApiOASPublic(ctx context.Context, apiID string) ApiDownloadApiOASPublicRequest

	// DownloadApiOASPublicExecute executes the request
	//  @return OASSchemaResponse
	DownloadApiOASPublicExecute(r ApiDownloadApiOASPublicRequest) (*OASSchemaResponse, *http.Response, error)

	/*
	DownloadApisOASPublic Method for DownloadApisOASPublic

	Download all OAS format APIs, when used without the Tyk Dashboard.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDownloadApisOASPublicRequest
	*/
	DownloadApisOASPublic(ctx context.Context) ApiDownloadApisOASPublicRequest

	// DownloadApisOASPublicExecute executes the request
	//  @return []OASSchemaResponse
	DownloadApisOASPublicExecute(r ApiDownloadApisOASPublicRequest) ([]OASSchemaResponse, *http.Response, error)

	/*
	ImportOAS Method for ImportOAS

	Create a new OAS format API, without x-tyk-gateway.
For use with an existing OAS API that you want to expose via your Tyk Gateway. (New)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiImportOASRequest
	*/
	ImportOAS(ctx context.Context) ApiImportOASRequest

	// ImportOASExecute executes the request
	//  @return ApiModifyKeySuccess
	ImportOASExecute(r ApiImportOASRequest) (*ApiModifyKeySuccess, *http.Response, error)

	/*
	ListApiOAS Method for ListApiOAS

	Get API definition in OAS format
Only if used without the Tyk Dashboard

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param apiID The API ID
	@return ApiListApiOASRequest
	*/
	ListApiOAS(ctx context.Context, apiID string) ApiListApiOASRequest

	// ListApiOASExecute executes the request
	//  @return OASSchemaResponse
	ListApiOASExecute(r ApiListApiOASRequest) (*OASSchemaResponse, *http.Response, error)

	/*
	ListApisOAS Method for ListApisOAS

	List all OAS format APIs, when used without the Tyk Dashboard.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListApisOASRequest
	*/
	ListApisOAS(ctx context.Context) ApiListApisOASRequest

	// ListApisOASExecute executes the request
	//  @return []OASSchemaResponse
	ListApisOASExecute(r ApiListApisOASRequest) ([]OASSchemaResponse, *http.Response, error)

	/*
	PatchApiOAS Patch a single OAS API by ID

	Update API with OAS format. You can use this endpoint to update OAS part of the tyk API definition.
This endpoint allows you to configure tyk OAS extension based on query params provided(similar to import)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param apiID The API ID
	@return ApiPatchApiOASRequest
	*/
	PatchApiOAS(ctx context.Context, apiID string) ApiPatchApiOASRequest

	// PatchApiOASExecute executes the request
	//  @return ApiModifyKeySuccess
	PatchApiOASExecute(r ApiPatchApiOASRequest) (*ApiModifyKeySuccess, *http.Response, error)

	/*
	UpdateApiOAS Method for UpdateApiOAS

	Updating an API definition uses the same signature an object as a `POST`, however it will first ensure that the API ID that is being updated is the same as the one in the object being `PUT`.


Updating will completely replace the file descriptor and will not change an API Definition that has already been loaded, the hot-reload endpoint will need to be called to push the new definition to live.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param apiID The API ID
	@return ApiUpdateApiOASRequest
	*/
	UpdateApiOAS(ctx context.Context, apiID string) ApiUpdateApiOASRequest

	// UpdateApiOASExecute executes the request
	//  @return ApiModifyKeySuccess
	UpdateApiOASExecute(r ApiUpdateApiOASRequest) (*ApiModifyKeySuccess, *http.Response, error)
}

// OASAPIsAPIService OASAPIsAPI service
type OASAPIsAPIService service

type ApiCreateApiOASRequest struct {
	ctx context.Context
	ApiService OASAPIsAPI
	schema *Schema
}

func (r ApiCreateApiOASRequest) Schema(schema Schema) ApiCreateApiOASRequest {
	r.schema = &schema
	return r
}

func (r ApiCreateApiOASRequest) Execute() (*ApiModifyKeySuccess, *http.Response, error) {
	return r.ApiService.CreateApiOASExecute(r)
}

/*
CreateApiOAS Method for CreateApiOAS

Create API with OAS format
 A single Tyk node can have its API Definitions queried, deleted and updated remotely. This functionality enables you to remotely update your Tyk definitions without having to manage the files manually.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateApiOASRequest
*/
func (a *OASAPIsAPIService) CreateApiOAS(ctx context.Context) ApiCreateApiOASRequest {
	return ApiCreateApiOASRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiModifyKeySuccess
func (a *OASAPIsAPIService) CreateApiOASExecute(r ApiCreateApiOASRequest) (*ApiModifyKeySuccess, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiModifyKeySuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OASAPIsAPIService.CreateApiOAS")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tyk/apis/oas"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.schema
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Tyk-Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteOASApiRequest struct {
	ctx context.Context
	ApiService OASAPIsAPI
	apiID string
}

func (r ApiDeleteOASApiRequest) Execute() (*ApiStatusMessage, *http.Response, error) {
	return r.ApiService.DeleteOASApiExecute(r)
}

/*
DeleteOASApi Method for DeleteOASApi

Deleting an API definition will remove the file from the file store, the API definition will NOT be unloaded, a separate reload request will need to be made to disable the API endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiID The API ID
 @return ApiDeleteOASApiRequest
*/
func (a *OASAPIsAPIService) DeleteOASApi(ctx context.Context, apiID string) ApiDeleteOASApiRequest {
	return ApiDeleteOASApiRequest{
		ApiService: a,
		ctx: ctx,
		apiID: apiID,
	}
}

// Execute executes the request
//  @return ApiStatusMessage
func (a *OASAPIsAPIService) DeleteOASApiExecute(r ApiDeleteOASApiRequest) (*ApiStatusMessage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiStatusMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OASAPIsAPIService.DeleteOASApi")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tyk/apis/oas/{apiID}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiID"+"}", url.PathEscape(parameterValueToString(r.apiID, "apiID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Tyk-Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadApiOASPublicRequest struct {
	ctx context.Context
	ApiService OASAPIsAPI
	apiID string
	mode *string
}

// Mode of OAS export, by default mode could be empty which means to export OAS spec including OAS Tyk extension.  When mode&#x3D;public, OAS spec excluding Tyk extension is exported
func (r ApiDownloadApiOASPublicRequest) Mode(mode string) ApiDownloadApiOASPublicRequest {
	r.mode = &mode
	return r
}

func (r ApiDownloadApiOASPublicRequest) Execute() (*OASSchemaResponse, *http.Response, error) {
	return r.ApiService.DownloadApiOASPublicExecute(r)
}

/*
DownloadApiOASPublic Method for DownloadApiOASPublic

Download all OAS format APIs, when used without the Tyk Dashboard.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiID The API ID
 @return ApiDownloadApiOASPublicRequest
*/
func (a *OASAPIsAPIService) DownloadApiOASPublic(ctx context.Context, apiID string) ApiDownloadApiOASPublicRequest {
	return ApiDownloadApiOASPublicRequest{
		ApiService: a,
		ctx: ctx,
		apiID: apiID,
	}
}

// Execute executes the request
//  @return OASSchemaResponse
func (a *OASAPIsAPIService) DownloadApiOASPublicExecute(r ApiDownloadApiOASPublicRequest) (*OASSchemaResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OASSchemaResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OASAPIsAPIService.DownloadApiOASPublic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tyk/apis/oas/{apiID}/export"
	localVarPath = strings.Replace(localVarPath, "{"+"apiID"+"}", url.PathEscape(parameterValueToString(r.apiID, "apiID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.mode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mode", r.mode, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Tyk-Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadApisOASPublicRequest struct {
	ctx context.Context
	ApiService OASAPIsAPI
	mode *string
}

// The mode of OAS export. By default the mode is not set which means the OAS spec is exported including the OAS Tyk extension.   If the mode is set to public, the OAS spec excluding the Tyk extension is exported.
func (r ApiDownloadApisOASPublicRequest) Mode(mode string) ApiDownloadApisOASPublicRequest {
	r.mode = &mode
	return r
}

func (r ApiDownloadApisOASPublicRequest) Execute() ([]OASSchemaResponse, *http.Response, error) {
	return r.ApiService.DownloadApisOASPublicExecute(r)
}

/*
DownloadApisOASPublic Method for DownloadApisOASPublic

Download all OAS format APIs, when used without the Tyk Dashboard.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDownloadApisOASPublicRequest
*/
func (a *OASAPIsAPIService) DownloadApisOASPublic(ctx context.Context) ApiDownloadApisOASPublicRequest {
	return ApiDownloadApisOASPublicRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []OASSchemaResponse
func (a *OASAPIsAPIService) DownloadApisOASPublicExecute(r ApiDownloadApisOASPublicRequest) ([]OASSchemaResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []OASSchemaResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OASAPIsAPIService.DownloadApisOASPublic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tyk/apis/oas/export"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.mode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mode", r.mode, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Tyk-Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiImportOASRequest struct {
	ctx context.Context
	ApiService OASAPIsAPI
	upstreamURL *string
	listenPath *string
	customDomain *string
	apiID *string
	allowList *BooleanQueryParam
	validateRequest *BooleanQueryParam
	authentication *BooleanQueryParam
	schema *Schema
}

// Upstream URL for the API
func (r ApiImportOASRequest) UpstreamURL(upstreamURL string) ApiImportOASRequest {
	r.upstreamURL = &upstreamURL
	return r
}

// Listen path for the API
func (r ApiImportOASRequest) ListenPath(listenPath string) ApiImportOASRequest {
	r.listenPath = &listenPath
	return r
}

// Custom domain for the API
func (r ApiImportOASRequest) CustomDomain(customDomain string) ApiImportOASRequest {
	r.customDomain = &customDomain
	return r
}

// ID of the API
func (r ApiImportOASRequest) ApiID(apiID string) ApiImportOASRequest {
	r.apiID = &apiID
	return r
}

// Enable allowList middleware for all endpoints
func (r ApiImportOASRequest) AllowList(allowList BooleanQueryParam) ApiImportOASRequest {
	r.allowList = &allowList
	return r
}

// Enable validateRequest middleware for all endpoints having a request body with media type application/json
func (r ApiImportOASRequest) ValidateRequest(validateRequest BooleanQueryParam) ApiImportOASRequest {
	r.validateRequest = &validateRequest
	return r
}

// Enable or disable authentication in your Tyk Gateway as per your OAS document.
func (r ApiImportOASRequest) Authentication(authentication BooleanQueryParam) ApiImportOASRequest {
	r.authentication = &authentication
	return r
}

func (r ApiImportOASRequest) Schema(schema Schema) ApiImportOASRequest {
	r.schema = &schema
	return r
}

func (r ApiImportOASRequest) Execute() (*ApiModifyKeySuccess, *http.Response, error) {
	return r.ApiService.ImportOASExecute(r)
}

/*
ImportOAS Method for ImportOAS

Create a new OAS format API, without x-tyk-gateway.
For use with an existing OAS API that you want to expose via your Tyk Gateway. (New)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiImportOASRequest
*/
func (a *OASAPIsAPIService) ImportOAS(ctx context.Context) ApiImportOASRequest {
	return ApiImportOASRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiModifyKeySuccess
func (a *OASAPIsAPIService) ImportOASExecute(r ApiImportOASRequest) (*ApiModifyKeySuccess, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiModifyKeySuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OASAPIsAPIService.ImportOAS")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tyk/apis/oas/import"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.upstreamURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "upstreamURL", r.upstreamURL, "")
	}
	if r.listenPath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "listenPath", r.listenPath, "")
	}
	if r.customDomain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customDomain", r.customDomain, "")
	}
	if r.apiID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apiID", r.apiID, "")
	}
	if r.allowList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowList", r.allowList, "")
	}
	if r.validateRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "validateRequest", r.validateRequest, "")
	}
	if r.authentication != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authentication", r.authentication, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.schema
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Tyk-Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListApiOASRequest struct {
	ctx context.Context
	ApiService OASAPIsAPI
	apiID string
	mode *string
}

// Mode of OAS get, by default mode could be empty which means to get OAS spec including OAS Tyk extension.  When mode&#x3D;public, OAS spec excluding Tyk extension will be returned in the response
func (r ApiListApiOASRequest) Mode(mode string) ApiListApiOASRequest {
	r.mode = &mode
	return r
}

func (r ApiListApiOASRequest) Execute() (*OASSchemaResponse, *http.Response, error) {
	return r.ApiService.ListApiOASExecute(r)
}

/*
ListApiOAS Method for ListApiOAS

Get API definition in OAS format
Only if used without the Tyk Dashboard

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiID The API ID
 @return ApiListApiOASRequest
*/
func (a *OASAPIsAPIService) ListApiOAS(ctx context.Context, apiID string) ApiListApiOASRequest {
	return ApiListApiOASRequest{
		ApiService: a,
		ctx: ctx,
		apiID: apiID,
	}
}

// Execute executes the request
//  @return OASSchemaResponse
func (a *OASAPIsAPIService) ListApiOASExecute(r ApiListApiOASRequest) (*OASSchemaResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OASSchemaResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OASAPIsAPIService.ListApiOAS")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tyk/apis/oas/{apiID}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiID"+"}", url.PathEscape(parameterValueToString(r.apiID, "apiID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.mode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mode", r.mode, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Tyk-Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListApisOASRequest struct {
	ctx context.Context
	ApiService OASAPIsAPI
	mode *string
}

// Mode of OAS get, by default mode could be empty which means to get OAS spec including OAS Tyk extension.  When mode&#x3D;public, OAS spec excluding Tyk extension will be returned in the response
func (r ApiListApisOASRequest) Mode(mode string) ApiListApisOASRequest {
	r.mode = &mode
	return r
}

func (r ApiListApisOASRequest) Execute() ([]OASSchemaResponse, *http.Response, error) {
	return r.ApiService.ListApisOASExecute(r)
}

/*
ListApisOAS Method for ListApisOAS

List all OAS format APIs, when used without the Tyk Dashboard.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListApisOASRequest
*/
func (a *OASAPIsAPIService) ListApisOAS(ctx context.Context) ApiListApisOASRequest {
	return ApiListApisOASRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []OASSchemaResponse
func (a *OASAPIsAPIService) ListApisOASExecute(r ApiListApisOASRequest) ([]OASSchemaResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []OASSchemaResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OASAPIsAPIService.ListApisOAS")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tyk/apis/oas"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.mode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mode", r.mode, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Tyk-Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchApiOASRequest struct {
	ctx context.Context
	ApiService OASAPIsAPI
	apiID string
	upstreamURL *string
	listenPath *string
	customDomain *string
	validateRequest *BooleanQueryParam
	allowList *BooleanQueryParam
	authentication *BooleanQueryParam
	schema *Schema
}

// Upstream URL for the API
func (r ApiPatchApiOASRequest) UpstreamURL(upstreamURL string) ApiPatchApiOASRequest {
	r.upstreamURL = &upstreamURL
	return r
}

// Listen path for the API
func (r ApiPatchApiOASRequest) ListenPath(listenPath string) ApiPatchApiOASRequest {
	r.listenPath = &listenPath
	return r
}

// Custom domain for the API
func (r ApiPatchApiOASRequest) CustomDomain(customDomain string) ApiPatchApiOASRequest {
	r.customDomain = &customDomain
	return r
}

// Enable validateRequest middleware for all endpoints having a request body with media type application/json
func (r ApiPatchApiOASRequest) ValidateRequest(validateRequest BooleanQueryParam) ApiPatchApiOASRequest {
	r.validateRequest = &validateRequest
	return r
}

// Enable allowList middleware for all endpoints
func (r ApiPatchApiOASRequest) AllowList(allowList BooleanQueryParam) ApiPatchApiOASRequest {
	r.allowList = &allowList
	return r
}

// Enable or disable authentication in your Tyk Gateway as per your OAS document.
func (r ApiPatchApiOASRequest) Authentication(authentication BooleanQueryParam) ApiPatchApiOASRequest {
	r.authentication = &authentication
	return r
}

func (r ApiPatchApiOASRequest) Schema(schema Schema) ApiPatchApiOASRequest {
	r.schema = &schema
	return r
}

func (r ApiPatchApiOASRequest) Execute() (*ApiModifyKeySuccess, *http.Response, error) {
	return r.ApiService.PatchApiOASExecute(r)
}

/*
PatchApiOAS Patch a single OAS API by ID

Update API with OAS format. You can use this endpoint to update OAS part of the tyk API definition.
This endpoint allows you to configure tyk OAS extension based on query params provided(similar to import)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiID The API ID
 @return ApiPatchApiOASRequest
*/
func (a *OASAPIsAPIService) PatchApiOAS(ctx context.Context, apiID string) ApiPatchApiOASRequest {
	return ApiPatchApiOASRequest{
		ApiService: a,
		ctx: ctx,
		apiID: apiID,
	}
}

// Execute executes the request
//  @return ApiModifyKeySuccess
func (a *OASAPIsAPIService) PatchApiOASExecute(r ApiPatchApiOASRequest) (*ApiModifyKeySuccess, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiModifyKeySuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OASAPIsAPIService.PatchApiOAS")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tyk/apis/oas/{apiID}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiID"+"}", url.PathEscape(parameterValueToString(r.apiID, "apiID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.upstreamURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "upstreamURL", r.upstreamURL, "")
	}
	if r.listenPath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "listenPath", r.listenPath, "")
	}
	if r.customDomain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customDomain", r.customDomain, "")
	}
	if r.validateRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "validateRequest", r.validateRequest, "")
	}
	if r.allowList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowList", r.allowList, "")
	}
	if r.authentication != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authentication", r.authentication, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.schema
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Tyk-Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateApiOASRequest struct {
	ctx context.Context
	ApiService OASAPIsAPI
	apiID string
	schema *Schema
}

func (r ApiUpdateApiOASRequest) Schema(schema Schema) ApiUpdateApiOASRequest {
	r.schema = &schema
	return r
}

func (r ApiUpdateApiOASRequest) Execute() (*ApiModifyKeySuccess, *http.Response, error) {
	return r.ApiService.UpdateApiOASExecute(r)
}

/*
UpdateApiOAS Method for UpdateApiOAS

Updating an API definition uses the same signature an object as a `POST`, however it will first ensure that the API ID that is being updated is the same as the one in the object being `PUT`.


Updating will completely replace the file descriptor and will not change an API Definition that has already been loaded, the hot-reload endpoint will need to be called to push the new definition to live.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiID The API ID
 @return ApiUpdateApiOASRequest
*/
func (a *OASAPIsAPIService) UpdateApiOAS(ctx context.Context, apiID string) ApiUpdateApiOASRequest {
	return ApiUpdateApiOASRequest{
		ApiService: a,
		ctx: ctx,
		apiID: apiID,
	}
}

// Execute executes the request
//  @return ApiModifyKeySuccess
func (a *OASAPIsAPIService) UpdateApiOASExecute(r ApiUpdateApiOASRequest) (*ApiModifyKeySuccess, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiModifyKeySuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OASAPIsAPIService.UpdateApiOAS")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tyk/apis/oas/{apiID}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiID"+"}", url.PathEscape(parameterValueToString(r.apiID, "apiID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.schema
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Tyk-Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
