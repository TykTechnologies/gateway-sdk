/*
Tyk Gateway API

The Tyk Gateway API is the primary means for integrating your application with the Tyk API Gateway system. This API is very small, and has no granular permissions system. It is intended to be used purely for internal automation and integration.  **Warning: Under no circumstances should outside parties be granted access to this API.**  The Tyk Gateway API is capable of:  * Managing session objects (key generation). * Managing and listing policies. * Managing and listing API Definitions (only when not using the Tyk Dashboard). * Hot reloads / reloading a cluster configuration. * OAuth client creation (only when not using the Tyk Dashboard).  In order to use the Gateway API, you'll need to set the **secret** parameter in your tyk.conf file.  The shared secret you set should then be sent along as a header with each Gateway API Request in order for it to be successful:  **x-tyk-authorization: <your-secret>*** <br/>  <b>The Tyk Gateway API is subsumed by the Tyk Dashboard API in Pro installations.</b>

API version: 5.7.1
Contact: support@tyk.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package apim

import (
	"encoding/json"
	"fmt"
	"gopkg.in/validator.v2"
)

// ListCertsWithIDs200Response - struct for ListCertsWithIDs200Response
type ListCertsWithIDs200Response struct {
	CertsCertificateMeta        *CertsCertificateMeta
	ArrayOfCertsCertificateMeta *[]CertsCertificateMeta
}

// CertsCertificateMetaAsListCertsWithIDs200Response is a convenience function that returns CertsCertificateMeta wrapped in ListCertsWithIDs200Response
func CertsCertificateMetaAsListCertsWithIDs200Response(v *CertsCertificateMeta) ListCertsWithIDs200Response {
	return ListCertsWithIDs200Response{
		CertsCertificateMeta: v,
	}
}

// []CertsCertificateMetaAsListCertsWithIDs200Response is a convenience function that returns []CertsCertificateMeta wrapped in ListCertsWithIDs200Response
func ArrayOfCertsCertificateMetaAsListCertsWithIDs200Response(v *[]CertsCertificateMeta) ListCertsWithIDs200Response {
	return ListCertsWithIDs200Response{
		ArrayOfCertsCertificateMeta: v,
	}
}

// Unmarshal JSON data into one of the pointers in the struct
func (dst *ListCertsWithIDs200Response) UnmarshalJSON(data []byte) error {
	var err error
	match := 0
	// try to unmarshal data into CertsCertificateMeta
	err = newStrictDecoder(data).Decode(&dst.CertsCertificateMeta)
	if err == nil {
		jsonCertsCertificateMeta, _ := json.Marshal(dst.CertsCertificateMeta)
		if string(jsonCertsCertificateMeta) == "{}" { // empty struct
			dst.CertsCertificateMeta = nil
		} else {
			if err = validator.Validate(dst.CertsCertificateMeta); err != nil {
				dst.CertsCertificateMeta = nil
			} else {
				match++
			}
		}
	} else {
		dst.CertsCertificateMeta = nil
	}

	// try to unmarshal data into ArrayOfCertsCertificateMeta
	err = newStrictDecoder(data).Decode(&dst.ArrayOfCertsCertificateMeta)
	if err == nil {
		jsonArrayOfCertsCertificateMeta, _ := json.Marshal(dst.ArrayOfCertsCertificateMeta)
		if string(jsonArrayOfCertsCertificateMeta) == "{}" { // empty struct
			dst.ArrayOfCertsCertificateMeta = nil
		} else {
			if err = validator.Validate(dst.ArrayOfCertsCertificateMeta); err != nil {
				dst.ArrayOfCertsCertificateMeta = nil
			} else {
				match++
			}
		}
	} else {
		dst.ArrayOfCertsCertificateMeta = nil
	}

	if match > 1 { // more than 1 match
		// reset to nil
		dst.CertsCertificateMeta = nil
		dst.ArrayOfCertsCertificateMeta = nil

		return fmt.Errorf("data matches more than one schema in oneOf(ListCertsWithIDs200Response)")
	} else if match == 1 {
		return nil // exactly one match
	} else { // no match
		return fmt.Errorf("data failed to match schemas in oneOf(ListCertsWithIDs200Response)")
	}
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src ListCertsWithIDs200Response) MarshalJSON() ([]byte, error) {
	if src.CertsCertificateMeta != nil {
		return json.Marshal(&src.CertsCertificateMeta)
	}

	if src.ArrayOfCertsCertificateMeta != nil {
		return json.Marshal(&src.ArrayOfCertsCertificateMeta)
	}

	return nil, nil // no data in oneOf schemas
}

// Get the actual instance
func (obj *ListCertsWithIDs200Response) GetActualInstance() interface{} {
	if obj == nil {
		return nil
	}
	if obj.CertsCertificateMeta != nil {
		return obj.CertsCertificateMeta
	}

	if obj.ArrayOfCertsCertificateMeta != nil {
		return obj.ArrayOfCertsCertificateMeta
	}

	// all schemas are nil
	return nil
}

type NullableListCertsWithIDs200Response struct {
	value *ListCertsWithIDs200Response
	isSet bool
}

func (v NullableListCertsWithIDs200Response) Get() *ListCertsWithIDs200Response {
	return v.value
}

func (v *NullableListCertsWithIDs200Response) Set(val *ListCertsWithIDs200Response) {
	v.value = val
	v.isSet = true
}

func (v NullableListCertsWithIDs200Response) IsSet() bool {
	return v.isSet
}

func (v *NullableListCertsWithIDs200Response) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableListCertsWithIDs200Response(val *ListCertsWithIDs200Response) *NullableListCertsWithIDs200Response {
	return &NullableListCertsWithIDs200Response{value: val, isSet: true}
}

func (v NullableListCertsWithIDs200Response) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableListCertsWithIDs200Response) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
