/*
Tyk Gateway API

The Tyk Gateway API is the primary means for integrating your application with the Tyk API Gateway system. This API is very small, and has no granular permissions system. It is intended to be used purely for internal automation and integration.  **Warning: Under no circumstances should outside parties be granted access to this API.**  The Tyk Gateway API is capable of:  * Managing session objects (key generation). * Managing and listing policies. * Managing and listing API Definitions (only when not using the Tyk Dashboard). * Hot reloads / reloading a cluster configuration. * OAuth client creation (only when not using the Tyk Dashboard).  In order to use the Gateway API, you'll need to set the **secret** parameter in your tyk.conf file.  The shared secret you set should then be sent along as a header with each Gateway API Request in order for it to be successful:  **x-tyk-authorization: <your-secret>*** <br/>  <b>The Tyk Gateway API is subsumed by the Tyk Dashboard API in Pro installations.</b>

API version: 5.7.1
Contact: support@tyk.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package apim

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"
)

type TykOASAPIsAPI interface {

	/*
		CreateApiOAS Create an API with Tyk OAS format.

		Create an API with Tyk OAS API format on the Tyk Gateway.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiCreateApiOASRequest
	*/
	CreateApiOAS(ctx context.Context) ApiCreateApiOASRequest

	// CreateApiOASExecute executes the request
	//  @return ApiModifyKeySuccess
	CreateApiOASExecute(r ApiCreateApiOASRequest) (*ApiModifyKeySuccess, *http.Response, error)

	/*
		DeleteOASApi Deleting a Tyk OAS API.

		Deleting an API definition will remove the file from the file store, the API definition will not be unloaded, a separate reload request will need to be made to disable the API endpoint.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param apiID The API ID.
		@return ApiDeleteOASApiRequest
	*/
	DeleteOASApi(ctx context.Context, apiID string) ApiDeleteOASApiRequest

	// DeleteOASApiExecute executes the request
	//  @return ApiModifyKeySuccess
	DeleteOASApiExecute(r ApiDeleteOASApiRequest) (*ApiModifyKeySuccess, *http.Response, error)

	/*
		DownloadApiOASPublic Download a Tyk OAS format API.

		Use the mode query parameter to specify if you want the x-tyk-api-gateway stripped out.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param apiID ID of the API you want to fetch.
		@return ApiDownloadApiOASPublicRequest
	*/
	DownloadApiOASPublic(ctx context.Context, apiID string) ApiDownloadApiOASPublicRequest

	// DownloadApiOASPublicExecute executes the request
	//  @return *os.File
	DownloadApiOASPublicExecute(r ApiDownloadApiOASPublicRequest) (*os.File, *http.Response, error)

	/*
		DownloadApisOASPublic Download all Tyk OAS format APIs.

		Download all Tyk OAS format APIs, from the Gateway.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiDownloadApisOASPublicRequest
	*/
	DownloadApisOASPublic(ctx context.Context) ApiDownloadApisOASPublicRequest

	// DownloadApisOASPublicExecute executes the request
	//  @return *os.File
	DownloadApisOASPublicExecute(r ApiDownloadApisOASPublicRequest) (*os.File, *http.Response, error)

	/*
		GetOASApi Get a Tyk OAS API definition.

		Get Tyk OAS API definition using an API ID.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param apiID ID of the API you want to fetch
		@return ApiGetOASApiRequest
	*/
	GetOASApi(ctx context.Context, apiID string) ApiGetOASApiRequest

	// GetOASApiExecute executes the request
	//  @return ListApisOAS200ResponseInner
	GetOASApiExecute(r ApiGetOASApiRequest) (*ListApisOAS200ResponseInner, *http.Response, error)

	/*
		ImportOAS Import an API in Tyk OAS format.

		Import an Tyk OAS format API without x-tyk-gateway.
	 For use with an existing Tyk OAS API that you want to expose via your Tyk Gateway.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiImportOASRequest
	*/
	ImportOAS(ctx context.Context) ApiImportOASRequest

	// ImportOASExecute executes the request
	//  @return ApiModifyKeySuccess
	ImportOASExecute(r ApiImportOASRequest) (*ApiModifyKeySuccess, *http.Response, error)

	/*
		ListApisOAS List all APIs in Tyk OAS API format.

		List all APIs in Tyk OAS API format, from Tyk Gateway.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiListApisOASRequest
	*/
	ListApisOAS(ctx context.Context) ApiListApisOASRequest

	// ListApisOASExecute executes the request
	//  @return []ListApisOAS200ResponseInner
	ListApisOASExecute(r ApiListApisOASRequest) ([]ListApisOAS200ResponseInner, *http.Response, error)

	/*
		ListOASApiVersions Listing versions of a Tyk OAS API.

		Listing versions of a Tyk OAS API.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param apiID ID of the API you want to fetch.
		@return ApiListOASApiVersionsRequest
	*/
	ListOASApiVersions(ctx context.Context, apiID string) ApiListOASApiVersionsRequest

	// ListOASApiVersionsExecute executes the request
	//  @return VersionMetas
	ListOASApiVersionsExecute(r ApiListOASApiVersionsRequest) (*VersionMetas, *http.Response, error)

	/*
		PatchApiOAS Patch API in Tyk OAS format.

		You can use this endpoint to update Tyk OAS part of the Tyk API definition.
	This endpoint allows you to configure Tyk OAS extension based on query params provided(similar to import).

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param apiID ID of the API you want to fetch.
		@return ApiPatchApiOASRequest
	*/
	PatchApiOAS(ctx context.Context, apiID string) ApiPatchApiOASRequest

	// PatchApiOASExecute executes the request
	//  @return ApiModifyKeySuccess
	PatchApiOASExecute(r ApiPatchApiOASRequest) (*ApiModifyKeySuccess, *http.Response, error)

	/*
		UpdateApiOAS Update a Tyk OAS API definition.

		Updating an API definition uses the same signature an object as a `POST`, however it will first ensure that the API ID that is being updated is the same as the one in the object being `PUT`.


	      Updating will completely replace the file descriptor and will not change an API Definition that has already been loaded, the hot-reload endpoint will need to be called to push the new definition to live.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param apiID ID of the API you want to fetch
		@return ApiUpdateApiOASRequest
	*/
	UpdateApiOAS(ctx context.Context, apiID string) ApiUpdateApiOASRequest

	// UpdateApiOASExecute executes the request
	//  @return ApiModifyKeySuccess
	UpdateApiOASExecute(r ApiUpdateApiOASRequest) (*ApiModifyKeySuccess, *http.Response, error)
}

// TykOASAPIsAPIService TykOASAPIsAPI service
type TykOASAPIsAPIService service

type ApiCreateApiOASRequest struct {
	ctx                         context.Context
	ApiService                  TykOASAPIsAPI
	baseApiId                   *string
	baseApiVersionName          *string
	newVersionName              *string
	setDefault                  *bool
	listApisOAS200ResponseInner *ListApisOAS200ResponseInner
}

// The base API which the new version will be linked to.
func (r ApiCreateApiOASRequest) BaseApiId(baseApiId string) ApiCreateApiOASRequest {
	r.baseApiId = &baseApiId
	return r
}

// The version name of the base API while creating the first version. This doesn&#39;t have to be sent for the next versions but if it is set, it will override base API version name.
func (r ApiCreateApiOASRequest) BaseApiVersionName(baseApiVersionName string) ApiCreateApiOASRequest {
	r.baseApiVersionName = &baseApiVersionName
	return r
}

// The version name of the created version.
func (r ApiCreateApiOASRequest) NewVersionName(newVersionName string) ApiCreateApiOASRequest {
	r.newVersionName = &newVersionName
	return r
}

// If true, the new version is set as default version.
func (r ApiCreateApiOASRequest) SetDefault(setDefault bool) ApiCreateApiOASRequest {
	r.setDefault = &setDefault
	return r
}

func (r ApiCreateApiOASRequest) ListApisOAS200ResponseInner(listApisOAS200ResponseInner ListApisOAS200ResponseInner) ApiCreateApiOASRequest {
	r.listApisOAS200ResponseInner = &listApisOAS200ResponseInner
	return r
}

func (r ApiCreateApiOASRequest) Execute() (*ApiModifyKeySuccess, *http.Response, error) {
	return r.ApiService.CreateApiOASExecute(r)
}

/*
CreateApiOAS Create an API with Tyk OAS format.

Create an API with Tyk OAS API format on the Tyk Gateway.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateApiOASRequest
*/
func (a *TykOASAPIsAPIService) CreateApiOAS(ctx context.Context) ApiCreateApiOASRequest {
	return ApiCreateApiOASRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ApiModifyKeySuccess
func (a *TykOASAPIsAPIService) CreateApiOASExecute(r ApiCreateApiOASRequest) (*ApiModifyKeySuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiModifyKeySuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TykOASAPIsAPIService.CreateApiOAS")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tyk/apis/oas"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.baseApiId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "base_api_id", r.baseApiId, "form", "")
	}
	if r.baseApiVersionName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "base_api_version_name", r.baseApiVersionName, "form", "")
	}
	if r.newVersionName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "new_version_name", r.newVersionName, "form", "")
	}
	if r.setDefault != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "set_default", r.setDefault, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.listApisOAS200ResponseInner
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Tyk-Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteOASApiRequest struct {
	ctx        context.Context
	ApiService TykOASAPIsAPI
	apiID      string
}

func (r ApiDeleteOASApiRequest) Execute() (*ApiModifyKeySuccess, *http.Response, error) {
	return r.ApiService.DeleteOASApiExecute(r)
}

/*
DeleteOASApi Deleting a Tyk OAS API.

Deleting an API definition will remove the file from the file store, the API definition will not be unloaded, a separate reload request will need to be made to disable the API endpoint.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param apiID The API ID.
	@return ApiDeleteOASApiRequest
*/
func (a *TykOASAPIsAPIService) DeleteOASApi(ctx context.Context, apiID string) ApiDeleteOASApiRequest {
	return ApiDeleteOASApiRequest{
		ApiService: a,
		ctx:        ctx,
		apiID:      apiID,
	}
}

// Execute executes the request
//
//	@return ApiModifyKeySuccess
func (a *TykOASAPIsAPIService) DeleteOASApiExecute(r ApiDeleteOASApiRequest) (*ApiModifyKeySuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiModifyKeySuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TykOASAPIsAPIService.DeleteOASApi")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tyk/apis/oas/{apiID}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiID"+"}", url.PathEscape(parameterValueToString(r.apiID, "apiID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Tyk-Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadApiOASPublicRequest struct {
	ctx        context.Context
	ApiService TykOASAPIsAPI
	apiID      string
	mode       *string
}

// By default mode is empty which means it will return the Tyk API OAS spec including the x-tyk-api-gateway part.   When mode&#x3D;public, the Tyk OAS API spec will exclude the x-tyk-api-gateway part in the response.
func (r ApiDownloadApiOASPublicRequest) Mode(mode string) ApiDownloadApiOASPublicRequest {
	r.mode = &mode
	return r
}

func (r ApiDownloadApiOASPublicRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.DownloadApiOASPublicExecute(r)
}

/*
DownloadApiOASPublic Download a Tyk OAS format API.

Use the mode query parameter to specify if you want the x-tyk-api-gateway stripped out.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param apiID ID of the API you want to fetch.
	@return ApiDownloadApiOASPublicRequest
*/
func (a *TykOASAPIsAPIService) DownloadApiOASPublic(ctx context.Context, apiID string) ApiDownloadApiOASPublicRequest {
	return ApiDownloadApiOASPublicRequest{
		ApiService: a,
		ctx:        ctx,
		apiID:      apiID,
	}
}

// Execute executes the request
//
//	@return *os.File
func (a *TykOASAPIsAPIService) DownloadApiOASPublicExecute(r ApiDownloadApiOASPublicRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TykOASAPIsAPIService.DownloadApiOASPublic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tyk/apis/oas/{apiID}/export"
	localVarPath = strings.Replace(localVarPath, "{"+"apiID"+"}", url.PathEscape(parameterValueToString(r.apiID, "apiID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.mode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mode", r.mode, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Tyk-Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadApisOASPublicRequest struct {
	ctx        context.Context
	ApiService TykOASAPIsAPI
	mode       *string
}

// By default mode is empty which means it will return the Tyk API OAS spec including the x-tyk-api-gateway part.   When mode&#x3D;public, the Tyk OAS API spec will exclude the x-tyk-api-gateway part in the response.
func (r ApiDownloadApisOASPublicRequest) Mode(mode string) ApiDownloadApisOASPublicRequest {
	r.mode = &mode
	return r
}

func (r ApiDownloadApisOASPublicRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.DownloadApisOASPublicExecute(r)
}

/*
DownloadApisOASPublic Download all Tyk OAS format APIs.

Download all Tyk OAS format APIs, from the Gateway.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDownloadApisOASPublicRequest
*/
func (a *TykOASAPIsAPIService) DownloadApisOASPublic(ctx context.Context) ApiDownloadApisOASPublicRequest {
	return ApiDownloadApisOASPublicRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return *os.File
func (a *TykOASAPIsAPIService) DownloadApisOASPublicExecute(r ApiDownloadApisOASPublicRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TykOASAPIsAPIService.DownloadApisOASPublic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tyk/apis/oas/export"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.mode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mode", r.mode, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Tyk-Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOASApiRequest struct {
	ctx        context.Context
	ApiService TykOASAPIsAPI
	apiID      string
	mode       *string
}

// By default mode is empty which means it will return the Tyk API OAS spec including the x-tyk-api-gateway part.   When mode&#x3D;public, the Tyk OAS API spec will exclude the x-tyk-api-gateway part in the response.
func (r ApiGetOASApiRequest) Mode(mode string) ApiGetOASApiRequest {
	r.mode = &mode
	return r
}

func (r ApiGetOASApiRequest) Execute() (*ListApisOAS200ResponseInner, *http.Response, error) {
	return r.ApiService.GetOASApiExecute(r)
}

/*
GetOASApi Get a Tyk OAS API definition.

Get Tyk OAS API definition using an API ID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param apiID ID of the API you want to fetch
	@return ApiGetOASApiRequest
*/
func (a *TykOASAPIsAPIService) GetOASApi(ctx context.Context, apiID string) ApiGetOASApiRequest {
	return ApiGetOASApiRequest{
		ApiService: a,
		ctx:        ctx,
		apiID:      apiID,
	}
}

// Execute executes the request
//
//	@return ListApisOAS200ResponseInner
func (a *TykOASAPIsAPIService) GetOASApiExecute(r ApiGetOASApiRequest) (*ListApisOAS200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListApisOAS200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TykOASAPIsAPIService.GetOASApi")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tyk/apis/oas/{apiID}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiID"+"}", url.PathEscape(parameterValueToString(r.apiID, "apiID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.mode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mode", r.mode, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Tyk-Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiImportOASRequest struct {
	ctx                context.Context
	ApiService         TykOASAPIsAPI
	upstreamURL        *string
	listenPath         *string
	customDomain       *string
	allowList          *bool
	validateRequest    *bool
	mockResponse       *bool
	authentication     *bool
	baseApiId          *string
	baseApiVersionName *string
	newVersionName     *string
	setDefault         *bool
	model30            *Model30
}

// Upstream URL for the API
func (r ApiImportOASRequest) UpstreamURL(upstreamURL string) ApiImportOASRequest {
	r.upstreamURL = &upstreamURL
	return r
}

// Listen path for the API
func (r ApiImportOASRequest) ListenPath(listenPath string) ApiImportOASRequest {
	r.listenPath = &listenPath
	return r
}

// Custom domain for the API
func (r ApiImportOASRequest) CustomDomain(customDomain string) ApiImportOASRequest {
	r.customDomain = &customDomain
	return r
}

// Enable allowList middleware for all endpoints
func (r ApiImportOASRequest) AllowList(allowList bool) ApiImportOASRequest {
	r.allowList = &allowList
	return r
}

// Enable validateRequest middleware for all endpoints having a request body with media type application/json
func (r ApiImportOASRequest) ValidateRequest(validateRequest bool) ApiImportOASRequest {
	r.validateRequest = &validateRequest
	return r
}

// Enable mockResponse middleware for all endpoints having responses configured.
func (r ApiImportOASRequest) MockResponse(mockResponse bool) ApiImportOASRequest {
	r.mockResponse = &mockResponse
	return r
}

// Enable/disable the authentication mechanism in your Tyk Gateway for your OAS API
func (r ApiImportOASRequest) Authentication(authentication bool) ApiImportOASRequest {
	r.authentication = &authentication
	return r
}

// The base API which the new version will be linked to.
func (r ApiImportOASRequest) BaseApiId(baseApiId string) ApiImportOASRequest {
	r.baseApiId = &baseApiId
	return r
}

// The version name of the base API while creating the first version. This doesn&#39;t have to be sent for the next versions but if it is set, it will override base API version name.
func (r ApiImportOASRequest) BaseApiVersionName(baseApiVersionName string) ApiImportOASRequest {
	r.baseApiVersionName = &baseApiVersionName
	return r
}

// The version name of the created version.
func (r ApiImportOASRequest) NewVersionName(newVersionName string) ApiImportOASRequest {
	r.newVersionName = &newVersionName
	return r
}

// If true, the new version is set as default version.
func (r ApiImportOASRequest) SetDefault(setDefault bool) ApiImportOASRequest {
	r.setDefault = &setDefault
	return r
}

func (r ApiImportOASRequest) Model30(model30 Model30) ApiImportOASRequest {
	r.model30 = &model30
	return r
}

func (r ApiImportOASRequest) Execute() (*ApiModifyKeySuccess, *http.Response, error) {
	return r.ApiService.ImportOASExecute(r)
}

/*
ImportOAS Import an API in Tyk OAS format.

Import an Tyk OAS format API without x-tyk-gateway.

	For use with an existing Tyk OAS API that you want to expose via your Tyk Gateway.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiImportOASRequest
*/
func (a *TykOASAPIsAPIService) ImportOAS(ctx context.Context) ApiImportOASRequest {
	return ApiImportOASRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ApiModifyKeySuccess
func (a *TykOASAPIsAPIService) ImportOASExecute(r ApiImportOASRequest) (*ApiModifyKeySuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiModifyKeySuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TykOASAPIsAPIService.ImportOAS")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tyk/apis/oas/import"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.upstreamURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "upstreamURL", r.upstreamURL, "form", "")
	}
	if r.listenPath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "listenPath", r.listenPath, "form", "")
	}
	if r.customDomain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customDomain", r.customDomain, "form", "")
	}
	if r.allowList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowList", r.allowList, "form", "")
	}
	if r.validateRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "validateRequest", r.validateRequest, "form", "")
	}
	if r.mockResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mockResponse", r.mockResponse, "form", "")
	}
	if r.authentication != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authentication", r.authentication, "form", "")
	}
	if r.baseApiId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "base_api_id", r.baseApiId, "form", "")
	}
	if r.baseApiVersionName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "base_api_version_name", r.baseApiVersionName, "form", "")
	}
	if r.newVersionName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "new_version_name", r.newVersionName, "form", "")
	}
	if r.setDefault != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "set_default", r.setDefault, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.model30
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Tyk-Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListApisOASRequest struct {
	ctx        context.Context
	ApiService TykOASAPIsAPI
	mode       *string
}

// By default mode is empty which means it will return the Tyk API OAS spec including the x-tyk-api-gateway part.   When mode&#x3D;public, the Tyk OAS API spec will exclude the x-tyk-api-gateway part in the response.
func (r ApiListApisOASRequest) Mode(mode string) ApiListApisOASRequest {
	r.mode = &mode
	return r
}

func (r ApiListApisOASRequest) Execute() ([]ListApisOAS200ResponseInner, *http.Response, error) {
	return r.ApiService.ListApisOASExecute(r)
}

/*
ListApisOAS List all APIs in Tyk OAS API format.

List all APIs in Tyk OAS API format, from Tyk Gateway.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListApisOASRequest
*/
func (a *TykOASAPIsAPIService) ListApisOAS(ctx context.Context) ApiListApisOASRequest {
	return ApiListApisOASRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []ListApisOAS200ResponseInner
func (a *TykOASAPIsAPIService) ListApisOASExecute(r ApiListApisOASRequest) ([]ListApisOAS200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ListApisOAS200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TykOASAPIsAPIService.ListApisOAS")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tyk/apis/oas"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.mode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mode", r.mode, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Tyk-Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListOASApiVersionsRequest struct {
	ctx        context.Context
	ApiService TykOASAPIsAPI
	apiID      string
	searchText *string
	accessType *string
}

// Search for API version name
func (r ApiListOASApiVersionsRequest) SearchText(searchText string) ApiListOASApiVersionsRequest {
	r.searchText = &searchText
	return r
}

// Filter for internal or external API versions
func (r ApiListOASApiVersionsRequest) AccessType(accessType string) ApiListOASApiVersionsRequest {
	r.accessType = &accessType
	return r
}

func (r ApiListOASApiVersionsRequest) Execute() (*VersionMetas, *http.Response, error) {
	return r.ApiService.ListOASApiVersionsExecute(r)
}

/*
ListOASApiVersions Listing versions of a Tyk OAS API.

Listing versions of a Tyk OAS API.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param apiID ID of the API you want to fetch.
	@return ApiListOASApiVersionsRequest
*/
func (a *TykOASAPIsAPIService) ListOASApiVersions(ctx context.Context, apiID string) ApiListOASApiVersionsRequest {
	return ApiListOASApiVersionsRequest{
		ApiService: a,
		ctx:        ctx,
		apiID:      apiID,
	}
}

// Execute executes the request
//
//	@return VersionMetas
func (a *TykOASAPIsAPIService) ListOASApiVersionsExecute(r ApiListOASApiVersionsRequest) (*VersionMetas, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VersionMetas
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TykOASAPIsAPIService.ListOASApiVersions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tyk/apis/oas/{apiID}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"apiID"+"}", url.PathEscape(parameterValueToString(r.apiID, "apiID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.searchText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchText", r.searchText, "form", "")
	}
	if r.accessType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accessType", r.accessType, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Tyk-Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchApiOASRequest struct {
	ctx             context.Context
	ApiService      TykOASAPIsAPI
	apiID           string
	upstreamURL     *string
	listenPath      *string
	customDomain    *string
	allowList       *bool
	validateRequest *bool
	mockResponse    *bool
	authentication  *bool
	model30         *Model30
}

// Upstream URL for the API
func (r ApiPatchApiOASRequest) UpstreamURL(upstreamURL string) ApiPatchApiOASRequest {
	r.upstreamURL = &upstreamURL
	return r
}

// Listen path for the API
func (r ApiPatchApiOASRequest) ListenPath(listenPath string) ApiPatchApiOASRequest {
	r.listenPath = &listenPath
	return r
}

// Custom domain for the API
func (r ApiPatchApiOASRequest) CustomDomain(customDomain string) ApiPatchApiOASRequest {
	r.customDomain = &customDomain
	return r
}

// Enable allowList middleware for all endpoints
func (r ApiPatchApiOASRequest) AllowList(allowList bool) ApiPatchApiOASRequest {
	r.allowList = &allowList
	return r
}

// Enable validateRequest middleware for all endpoints having a request body with media type application/json
func (r ApiPatchApiOASRequest) ValidateRequest(validateRequest bool) ApiPatchApiOASRequest {
	r.validateRequest = &validateRequest
	return r
}

// Enable mockResponse middleware for all endpoints having responses configured.
func (r ApiPatchApiOASRequest) MockResponse(mockResponse bool) ApiPatchApiOASRequest {
	r.mockResponse = &mockResponse
	return r
}

// Enable/disable the authentication mechanism in your Tyk Gateway for your OAS API
func (r ApiPatchApiOASRequest) Authentication(authentication bool) ApiPatchApiOASRequest {
	r.authentication = &authentication
	return r
}

func (r ApiPatchApiOASRequest) Model30(model30 Model30) ApiPatchApiOASRequest {
	r.model30 = &model30
	return r
}

func (r ApiPatchApiOASRequest) Execute() (*ApiModifyKeySuccess, *http.Response, error) {
	return r.ApiService.PatchApiOASExecute(r)
}

/*
PatchApiOAS Patch API in Tyk OAS format.

You can use this endpoint to update Tyk OAS part of the Tyk API definition.
This endpoint allows you to configure Tyk OAS extension based on query params provided(similar to import).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param apiID ID of the API you want to fetch.
	@return ApiPatchApiOASRequest
*/
func (a *TykOASAPIsAPIService) PatchApiOAS(ctx context.Context, apiID string) ApiPatchApiOASRequest {
	return ApiPatchApiOASRequest{
		ApiService: a,
		ctx:        ctx,
		apiID:      apiID,
	}
}

// Execute executes the request
//
//	@return ApiModifyKeySuccess
func (a *TykOASAPIsAPIService) PatchApiOASExecute(r ApiPatchApiOASRequest) (*ApiModifyKeySuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiModifyKeySuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TykOASAPIsAPIService.PatchApiOAS")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tyk/apis/oas/{apiID}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiID"+"}", url.PathEscape(parameterValueToString(r.apiID, "apiID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.upstreamURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "upstreamURL", r.upstreamURL, "form", "")
	}
	if r.listenPath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "listenPath", r.listenPath, "form", "")
	}
	if r.customDomain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customDomain", r.customDomain, "form", "")
	}
	if r.allowList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowList", r.allowList, "form", "")
	}
	if r.validateRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "validateRequest", r.validateRequest, "form", "")
	}
	if r.mockResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mockResponse", r.mockResponse, "form", "")
	}
	if r.authentication != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authentication", r.authentication, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.model30
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Tyk-Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateApiOASRequest struct {
	ctx                         context.Context
	ApiService                  TykOASAPIsAPI
	apiID                       string
	listApisOAS200ResponseInner *ListApisOAS200ResponseInner
}

func (r ApiUpdateApiOASRequest) ListApisOAS200ResponseInner(listApisOAS200ResponseInner ListApisOAS200ResponseInner) ApiUpdateApiOASRequest {
	r.listApisOAS200ResponseInner = &listApisOAS200ResponseInner
	return r
}

func (r ApiUpdateApiOASRequest) Execute() (*ApiModifyKeySuccess, *http.Response, error) {
	return r.ApiService.UpdateApiOASExecute(r)
}

/*
UpdateApiOAS Update a Tyk OAS API definition.

Updating an API definition uses the same signature an object as a `POST`, however it will first ensure that the API ID that is being updated is the same as the one in the object being `PUT`.

	     Updating will completely replace the file descriptor and will not change an API Definition that has already been loaded, the hot-reload endpoint will need to be called to push the new definition to live.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param apiID ID of the API you want to fetch
	@return ApiUpdateApiOASRequest
*/
func (a *TykOASAPIsAPIService) UpdateApiOAS(ctx context.Context, apiID string) ApiUpdateApiOASRequest {
	return ApiUpdateApiOASRequest{
		ApiService: a,
		ctx:        ctx,
		apiID:      apiID,
	}
}

// Execute executes the request
//
//	@return ApiModifyKeySuccess
func (a *TykOASAPIsAPIService) UpdateApiOASExecute(r ApiUpdateApiOASRequest) (*ApiModifyKeySuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiModifyKeySuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TykOASAPIsAPIService.UpdateApiOAS")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tyk/apis/oas/{apiID}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiID"+"}", url.PathEscape(parameterValueToString(r.apiID, "apiID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.listApisOAS200ResponseInner
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Tyk-Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
